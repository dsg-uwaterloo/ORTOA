// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Send_Op.h"
#include "clientHelper.h"
#include "gen-cpp/KV_RPC.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>

#include <atomic>

#include <thread>
#include <algorithm>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;


#include "constants.h"


KV_RPCClient* client = NULL;
std::atomic<int> accesses{0};
std::atomic<int> aborted{0};

void handleOp(Operation op, std::string* _return){
    if(!keySet.count(op.key)) {
        if(op.op == "GET") {
        //   std::cerr << "No such key exists" << std::endl;
          *_return = "";
          aborted++;
        } else {
          if(locks[op.key].exchange(false)){
            Entry createEntry = constructCreateEntry(op.key, op.value);
            valueSizes[op.key] = op.value.length();
            keySet.insert(op.key);

            client->create(createEntry);
            accesses++;
            locks[op.key].exchange(true);
          }
          else{
            aborted++;
          }
        }
      } else {
        if(locks[op.key].exchange(false)){
            if(op.op == "GET") {
            Entry getEntry = constructGetEntry(op.key);
            std::string labels;
            client->access(labels, getEntry);

            std::string value = readValueFromLabels(op.key, labels);
            *_return = value;
            } else {
            Entry putEntry = constructPutEntry(op.key, op.value);
            valueSizes[op.key] = op.value.length();
            std::string labels;
            
            client->access(labels, putEntry);
            }
            accesses++;
            locks[op.key].exchange(true);
        }
        else{
            aborted++;
        }
      }

      //std::cerr << (op.type ? "PUT" : "GET") << " " << op.key << " " << op.value << std::endl;  
}




class Send_OpHandler : virtual public Send_OpIf {
 public:

  Send_OpHandler() {
    ::std::shared_ptr<TTransport> socket(new TSocket(SERVER_IP, SERVER_PORT));
    ::std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    ::std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    client = new KV_RPCClient(protocol);
    OpScureSetup(DATA_FILE);
    transport->open();

  }

  void access(std::string& _return, const Operation& operation) {
    Operation op;
    op.__set_op(operation.op);
    op.__set_key(operation.key);
    op.__set_value(operation.value);
    handleOp(op, &_return);
  }

};

void signal_callback_handler(int signum) {
   OpScureCleanup(DATA_FILE);
   std::cout << "Accesses: " << accesses << std::endl;
   std::cout << "Aborted: " << aborted << std::endl;
   // Terminate program
   exit(signum);
}

int main(int argc, char **argv) {
  signal(SIGINT, signal_callback_handler);
  int port = PROXY_PORT;
  ::std::shared_ptr<Send_OpHandler> handler(new Send_OpHandler());
  ::std::shared_ptr<TProcessor> processor(new Send_OpProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

